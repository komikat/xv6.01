#include <netdb.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/socket.h>#include <unistd.h>#define PORT1 "2050"#define PORT2 "2051"#define BACKLOG 10#define BUFLEN 1000int decision(int a1, int a2) {  // rock 0  // paper 1  // scissor 2  // rock > sc  // paper > rock  // sc > paper  // 0 -> a1 won  // 1 -> a2 won  // -1 -> tie  if (a1 == a2)    return -1;  // a1 rock  if (a1 == 0)      return a2%2;  // a1 paper  if (a1 == 1)      return a2/2;  // a1 scissor  if (a1 == 2)    return (a2+1)%2;  else return 2;}// Inspired (and learnt) a lot from:// https://beej.us/guide/bgnet/html//index.htmlint main() {  int status, sockfd1, sockfd2;  struct addrinfo hints1, hints2;  struct addrinfo *result1, *result2, *p;  memset(&hints1, 0, sizeof hints1); // empty struct  hints1.ai_family = AF_UNSPEC;     // ipv4/6  hints1.ai_socktype = SOCK_DGRAM; // tcp  hints1.ai_flags = AI_PASSIVE;     // assigns the address of local host                                   // to the socket  memset(&hints2, 0, sizeof hints2); // empty struct  hints2.ai_family = AF_UNSPEC;     // ipv4/6  hints2.ai_socktype = SOCK_DGRAM; // tcp  hints2.ai_flags = AI_PASSIVE;     // assigns the address of local host                                   // to the socket  if ((status = getaddrinfo("localhost", PORT1, &hints1, &result1)) != 0) {    fprintf(stderr, "Error with getting address: %s\n", gai_strerror(status));    exit(1);  }  if ((status = getaddrinfo("localhost", PORT2, &hints2, &result2)) != 0) {    fprintf(stderr, "Error with getting address: %s\n", gai_strerror(status));    exit(1);  }  // result -> linked list of addrinfos for localhost:PORT  // loop through the entire linked list  for (p = result1; p != NULL; p = p->ai_next) {    if ((sockfd1 = socket(p->ai_family, p->ai_socktype,                         p->ai_protocol)) == -1) {      continue;    }    if (bind(sockfd1, p->ai_addr, p->ai_addrlen) == -1) {      close(sockfd1);      continue;    }    break;  }  if (p == NULL) {    fprintf(stderr, "Failed to bind\n");    exit(1);  }  for (p = result2; p != NULL; p = p->ai_next) {    if ((sockfd2 = socket(p->ai_family, p->ai_socktype,                         p->ai_protocol)) == -1) {      continue;    }    if (bind(sockfd2, p->ai_addr, p->ai_addrlen) == -1) {      close(sockfd2);      continue;    }    break;  }  if (p == NULL) {    fprintf(stderr, "Failed to bind\n");    exit(1);  }  printf("Server up!\n");  // keep accepting requests  for (;;) {    struct sockaddr_storage client_addr1, client_addr2;    socklen_t addr_len1 = sizeof client_addr1;    socklen_t addr_len2 = sizeof client_addr2;    int new_fd;    char buf1[BUFLEN] = {0};    char buf2[BUFLEN] = {0};    // get from first client    if (recvfrom(sockfd1, buf1, 1, 0, (struct sockaddr *)&client_addr1,                 &addr_len1) == -1) {      fprintf(stderr, "Issues getting reqs");      exit(1);    }    // get from next client    if (recvfrom(sockfd2, buf2, 1, 0, (struct sockaddr *)&client_addr2,                 &addr_len2) == -1) {      fprintf(stderr, "Issues getting reqs");      exit(1);    }    int a1 = buf1[0] - '0';    int a2 = buf2[0] - '0';    int dec = decision(a1, a2);    char *msg1, *msg2;    if (dec == -1)    {      msg1 = msg2 = "Draw!";    }    else if (dec == 1) {      msg1 = "Lost! :(";      msg2 = "Win! :)";    }    else if (dec == 0) {      msg1 = "Won";      msg2 = "Lose";    }    int len1 = strlen(msg1);    int len2 = strlen(msg2);    if ((sendto(sockfd1, msg1, len1, 0, (struct sockaddr *)&client_addr1,                addr_len1)) == -1) {      perror("talker: sendto");      exit(1);    }    if ((sendto(sockfd2, msg2, len2, 0, (struct sockaddr *)&client_addr2,                addr_len2)) == -1) {      perror("talker: sendto");      exit(1);    }    if (recvfrom(sockfd1, buf1, BUFLEN, 0, (struct sockaddr *)&client_addr1,                 &addr_len1) == -1) {      fprintf(stderr, "Issues getting reqs");      exit(1);    }    if (recvfrom(sockfd2, buf2, BUFLEN, 0, (struct sockaddr *)&client_addr2,                 &addr_len2) == -1) {      fprintf(stderr, "Issues getting reqs");      exit(1);    }    a1 = buf1[0] - '0';    a2 = buf2[0] - '0';    if (!(a1 && a2)) {      // if not continue      if ((sendto(sockfd1, "0", 1, 0, (struct sockaddr *)&client_addr1,                  addr_len1)) == -1) {        perror("talker: sendto");        exit(1);      }      if ((sendto(sockfd2, "0", 1, 0, (struct sockaddr *)&client_addr2,                  addr_len2)) == -1) {        perror("talker: sendto");        exit(1);      }      break;    }    else {      if ((sendto(sockfd1, "1", 1, 0, (struct sockaddr *)&client_addr1,                  addr_len1)) == -1) {        perror("talker: sendto");        exit(1);      }      if ((sendto(sockfd2, "1", 1, 0, (struct sockaddr *)&client_addr2,                  addr_len2)) == -1) {        perror("talker: sendto");        exit(1);      }    }  }  close(sockfd1);  close(sockfd2);  freeaddrinfo(result1);  freeaddrinfo(result2);}